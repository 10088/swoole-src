/**
 * Generated by build-library.php, Please DO NOT modify!
 */

static const char* swoole_library_source_constant =
    "\n"
    "define('SWOOLE_LIBRARY', true);\n";

static const char* swoole_library_source_std_array =
    "\n"
    "function swoole_array_walk(array &$array, callable $callback, $userdata = null): bool\n"
    "{\n"
    "    foreach ($array as $key => &$item) {\n"
    "        $callback($item, $key, $userdata);\n"
    "    }\n"
    "    return true;\n"
    "}\n"
    "\n"
    "function swoole_array_walk_recursive(array &$array, callable $callback, $userdata = null): bool\n"
    "{\n"
    "    foreach ($array as $key => &$item) {\n"
    "        if (is_array($item)) {\n"
    "            swoole_array_walk_recursive($item, $callback, $userdata);\n"
    "        } else {\n"
    "            $callback($item, $key, $userdata);\n"
    "        }\n"
    "    }\n"
    "    return true;\n"
    "}\n";

static const char* swoole_library_source_ext_curl =
    "\n"
    "\n"
    "class swoole_curl_handler\n"
    "{\n"
    "    /** @var Swoole\\Coroutine\\Http\\Client */\n"
    "    private $client;\n"
    "    private $info;\n"
    "    private $outputStream;\n"
    "\n"
    "    /** @var callable */\n"
    "    private $headerFunction;\n"
    "    /** @var callable */\n"
    "    private $readFunction;\n"
    "    /** @var callable */\n"
    "    private $writeFunction;\n"
    "    /** @var callable */\n"
    "    private $progressFunction;\n"
    "\n"
    "    public $returnTransfer = true;\n"
    "    public $method = 'GET';\n"
    "    public $headers = [];\n"
    "\n"
    "    function create(string $url)\n"
    "    {\n"
    "        $info = parse_url($url);\n"
    "        $ssl = $info['scheme'] === 'https';\n"
    "        if (empty($info['port'])) {\n"
    "            $port = $ssl ? 443 : 80;\n"
    "        } else {\n"
    "            $port = intval($info['port']);\n"
    "        }\n"
    "        $this->info = $info;\n"
    "        $this->client = new Swoole\\Coroutine\\Http\\Client($info['host'], $port, $ssl);\n"
    "    }\n"
    "\n"
    "    function execute()\n"
    "    {\n"
    "        $client = $this->client;\n"
    "        $client->setMethod($this->method);\n"
    "        if ($this->headers) {\n"
    "            $client->setHeaders($this->headers);\n"
    "        }\n"
    "        if (!$client->execute($this->getUrl())) {\n"
    "            return false;\n"
    "        }\n"
    "\n"
    "        if ($client->headers and $this->headerFunction) {\n"
    "            $cb = $this->headerFunction;\n"
    "            if ($client->statusCode === 200) {\n"
    "                $cb($this, \"HTTP/1.1 200 OK\\r\\n\");\n"
    "            }\n"
    "            foreach ($client->headers as $k => $v) {\n"
    "                $cb($this, \"$k: $v\\r\\n\");\n"
    "            }\n"
    "            $cb($this, '');\n"
    "        }\n"
    "\n"
    "        if ($client->body and $this->readFunction) {\n"
    "            $cb = $this->readFunction;\n"
    "            $cb($this, $this->outputStream, strlen($client->body));\n"
    "        }\n"
    "\n"
    "        if ($this->returnTransfer) {\n"
    "            return $client->body;\n"
    "        } else {\n"
    "            if ($this->outputStream) {\n"
    "                return fwrite($this->outputStream, $client->body) === strlen($client->body);\n"
    "            } else {\n"
    "                echo $this->outputStream;\n"
    "            }\n"
    "            return true;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    function close(): void\n"
    "    {\n"
    "        $this->client = null;\n"
    "    }\n"
    "\n"
    "    function getErrorCode(): int\n"
    "    {\n"
    "        return $this->client->errCode;\n"
    "    }\n"
    "\n"
    "    function getErrorMsg(): string\n"
    "    {\n"
    "        return $this->client->errMsg;\n"
    "    }\n"
    "\n"
    "    private function getUrl(): string\n"
    "    {\n"
    "        if (empty($this->info['path'])) {\n"
    "            $url = '/';\n"
    "        } else {\n"
    "            $url = $this->info['path'];\n"
    "        }\n"
    "        if (!empty($this->info['query'])) {\n"
    "            $url .= '?' . $this->info['query'];\n"
    "        }\n"
    "        if (!empty($this->info['query'])) {\n"
    "            $url .= '#' . $this->info['fragment'];\n"
    "        }\n"
    "        return $url;\n"
    "    }\n"
    "\n"
    "    function setOption(int $opt, $value): bool\n"
    "    {\n"
    "        switch ($opt) {\n"
    "            case CURLOPT_URL:\n"
    "                $this->create($value);\n"
    "                break;\n"
    "            case CURLOPT_RETURNTRANSFER:\n"
    "                $this->returnTransfer = $value;\n"
    "                break;\n"
    "            case CURLOPT_ENCODING:\n"
    "                if (empty($value)) {\n"
    "                    $value = 'gzip';\n"
    "                }\n"
    "                $this->headers['Accept-Encoding'] = $value;\n"
    "                break;\n"
    "            case CURLOPT_POST:\n"
    "                $this->method = 'POST';\n"
    "                break;\n"
    "            case CURLOPT_HTTPHEADER:\n"
    "                foreach ($value as $header) {\n"
    "                    list($k, $v) = explode(':', $header);\n"
    "                    $v = trim($v);\n"
    "                    if ($v) {\n"
    "                        $this->headers[$k] = $v;\n"
    "                    }\n"
    "                }\n"
    "                break;\n"
    "            case CURLOPT_CUSTOMREQUEST:\n"
    "                break;\n"
    "            case CURLOPT_PROTOCOLS:\n"
    "                if ($value > 3) {\n"
    "                    throw new swoole_curl_exception(\"option[{$opt}={$value}] not supported\");\n"
    "                }\n"
    "                break;\n"
    "            case CURLOPT_HTTP_VERSION:\n"
    "                break;\n"
    "            case CURLOPT_SSL_VERIFYHOST:\n"
    "                break;\n"
    "            case CURLOPT_SSL_VERIFYPEER:\n"
    "                $this->client->set(['ssl_verify_peer' => $value]);\n"
    "                break;\n"
    "            case CURLOPT_CONNECTTIMEOUT:\n"
    "                $this->client->set(['connect_timeout' => $value]);\n"
    "                break;\n"
    "            case CURLOPT_FILE:\n"
    "                $this->outputStream = $value;\n"
    "                break;\n"
    "            case CURLOPT_HEADER:\n"
    "                break;\n"
    "            case CURLOPT_HEADERFUNCTION:\n"
    "                $this->headerFunction = $value;\n"
    "                break;\n"
    "            case CURLOPT_READFUNCTION:\n"
    "                $this->readFunction = $value;\n"
    "                break;\n"
    "            case CURLOPT_WRITEFUNCTION:\n"
    "                $this->writeFunction = $value;\n"
    "                break;\n"
    "            case CURLOPT_PROGRESSFUNCTION:\n"
    "                $this->progressFunction = $value;\n"
    "                break;\n"
    "            default:\n"
    "                throw new swoole_curl_exception(\"option[{$opt}] not supported\");\n"
    "        }\n"
    "        return true;\n"
    "    }\n"
    "\n"
    "    function reset(): void\n"
    "    {\n"
    "        $this->client->body = '';\n"
    "    }\n"
    "}\n"
    "\n"
    "class swoole_curl_exception extends swoole_exception\n"
    "{\n"
    "\n"
    "}\n"
    "\n"
    "function swoole_curl_init(): swoole_curl_handler\n"
    "{\n"
    "    return new swoole_curl_handler();\n"
    "}\n"
    "\n"
    "function swoole_curl_setopt(swoole_curl_handler $obj, $opt, $value): bool\n"
    "{\n"
    "    return $obj->setOption($opt, $value);\n"
    "}\n"
    "\n"
    "function swoole_curl_setopt_array(swoole_curl_handler $obj, $array): bool\n"
    "{\n"
    "    foreach ($array as $k => $v) {\n"
    "        if ($obj->setOption($k, $v) === false) {\n"
    "            return false;\n"
    "        }\n"
    "    }\n"
    "    return true;\n"
    "}\n"
    "\n"
    "function swoole_curl_exec(swoole_curl_handler $obj)\n"
    "{\n"
    "    return $obj->execute();\n"
    "}\n"
    "\n"
    "function swoole_curl_close(swoole_curl_handler $obj): void\n"
    "{\n"
    "    $obj->close();\n"
    "}\n"
    "\n"
    "function swoole_curl_error(swoole_curl_handler $obj): string\n"
    "{\n"
    "    return $obj->getErrorMsg();\n"
    "}\n"
    "\n"
    "function swoole_curl_errno(swoole_curl_handler $obj): int\n"
    "{\n"
    "    return $obj->getErrorCode();\n"
    "}\n"
    "\n"
    "function swoole_curl_reset(swoole_curl_handler $obj): void\n"
    "{\n"
    "    $obj->reset();\n"
    "}\n";

static const char* swoole_library_source_core_coroutine_wait_group =
    "\n"
    "\n"
    "namespace Swoole\\Coroutine;\n"
    "\n"
    "use BadMethodCallException;\n"
    "use InvalidArgumentException;\n"
    "\n"
    "class WaitGroup\n"
    "{\n"
    "    protected $chan;\n"
    "    protected $count = 0;\n"
    "    protected $waiting = false;\n"
    "\n"
    "    public function __construct()\n"
    "    {\n"
    "        $this->chan = new Channel(1);\n"
    "    }\n"
    "\n"
    "    public function add(int $delta = 1): void\n"
    "    {\n"
    "        if ($this->waiting) {\n"
    "            throw new BadMethodCallException('WaitGroup misuse: add called concurrently with wait');\n"
    "        }\n"
    "        $count = $this->count + $delta;\n"
    "        if ($count < 0) {\n"
    "            throw new InvalidArgumentException('negative WaitGroup counter');\n"
    "        }\n"
    "        $this->count = $count;\n"
    "    }\n"
    "\n"
    "    public function done(): void\n"
    "    {\n"
    "        $count = $this->count - 1;\n"
    "        if ($count < 0) {\n"
    "            throw new BadMethodCallException('negative WaitGroup counter');\n"
    "        }\n"
    "        $this->count = $count;\n"
    "        if ($count === 0 && $this->waiting) {\n"
    "            $this->chan->push(true);\n"
    "        }\n"
    "    }\n"
    "\n"
    "    public function wait(): void\n"
    "    {\n"
    "        if ($this->count > 0) {\n"
    "            $this->waiting = true;\n"
    "            $this->chan->pop();\n"
    "            $this->waiting = false;\n"
    "        }\n"
    "    }\n"
    "}\n";

static const char* swoole_library_source_core_string_object =
    "\n"
    "namespace Swoole;\n"
    "\n"
    "class StringObject\n"
    "{\n"
    "    /**\n"
    "     * @var string\n"
    "     */\n"
    "    protected $string;\n"
    "\n"
    "    /**\n"
    "     * StringObject constructor.\n"
    "     * @param $string\n"
    "     */\n"
    "    function __construct(string $string)\n"
    "    {\n"
    "        $this->string = $string;\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return string\n"
    "     */\n"
    "    function __toString()\n"
    "    {\n"
    "        return $this->string;\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $find_str\n"
    "     * @return bool|int\n"
    "     */\n"
    "    function indexOf($find_str)\n"
    "    {\n"
    "        return strpos($this->string, $find_str);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $find_str\n"
    "     * @return bool|int\n"
    "     */\n"
    "    function lastIndexOf($find_str)\n"
    "    {\n"
    "        return strrpos($this->string, $find_str);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $find_str\n"
    "     * @return bool|int\n"
    "     */\n"
    "    function pos($find_str)\n"
    "    {\n"
    "        return strpos($this->string, $find_str);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $find_str\n"
    "     * @return bool|int\n"
    "     */\n"
    "    function rpos($find_str)\n"
    "    {\n"
    "        return strrpos($this->string, $find_str);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $find_str\n"
    "     * @return int\n"
    "     */\n"
    "    function ipos($find_str)\n"
    "    {\n"
    "        return stripos($this->string, $find_str);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return StringObject\n"
    "     */\n"
    "    function lower()\n"
    "    {\n"
    "        return new StringObject(strtolower($this->string));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return StringObject\n"
    "     */\n"
    "    function upper()\n"
    "    {\n"
    "        return new StringObject(strtoupper($this->string));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return StringObject\n"
    "     */\n"
    "    function trim()\n"
    "    {\n"
    "        return new StringObject(trim($this->string));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return int\n"
    "     */\n"
    "    function len()\n"
    "    {\n"
    "        return strlen($this->string);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $offset\n"
    "     * @param null $length\n"
    "     * @return StringObject\n"
    "     */\n"
    "    function substr($offset, $length = null)\n"
    "    {\n"
    "        return new StringObject(substr($this->string, $offset, $length));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $search\n"
    "     * @param $replace\n"
    "     * @param null $count\n"
    "     * @return StringObject\n"
    "     */\n"
    "    function replace($search, $replace, &$count = null)\n"
    "    {\n"
    "        return new StringObject(str_replace($search, $replace, $this->string, $count));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $needle\n"
    "     * @return bool\n"
    "     */\n"
    "    function  startsWith($needle)\n"
    "    {\n"
    "        return $this->pos($needle) === 0;\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $subString\n"
    "     * @return bool\n"
    "     */\n"
    "    function contains($subString)\n"
    "    {\n"
    "        return $this->pos($subString) !== false;\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $needle\n"
    "     * @return bool\n"
    "     */\n"
    "    function endsWith($needle)\n"
    "    {\n"
    "        $length = strlen($needle);\n"
    "        if ($length == 0)\n"
    "        {\n"
    "            return true;\n"
    "        }\n"
    "        return (substr($this->string, -$length) === $needle);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $sp\n"
    "     * @param int $limit\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function split($sp, $limit = PHP_INT_MAX)\n"
    "    {\n"
    "        return new ArrayObject(explode($sp, $this->string, $limit));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $index\n"
    "     * @return string\n"
    "     */\n"
    "    function char($index)\n"
    "    {\n"
    "        return $this->string[$index];\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param int $splitLength\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function toArray($splitLength = 1)\n"
    "    {\n"
    "        return new ArrayObject(str_split($this->string, $splitLength));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return mixed\n"
    "     */\n"
    "    function toSring()\n"
    "    {\n"
    "        return $this->__toString();\n"
    "    }\n"
    "}\n";

static const char* swoole_library_source_core_array_object =
    "\n"
    "namespace Swoole;\n"
    "\n"
    "class ArrayObject implements \\ArrayAccess, \\Serializable, \\Countable, \\Iterator\n"
    "{\n"
    "    protected $array;\n"
    "\n"
    "    function __construct($array = array())\n"
    "    {\n"
    "        $this->array = $array;\n"
    "    }\n"
    "\n"
    "    function current()\n"
    "    {\n"
    "        return current($this->array);\n"
    "    }\n"
    "\n"
    "    function key()\n"
    "    {\n"
    "        return key($this->array);\n"
    "    }\n"
    "\n"
    "    function valid()\n"
    "    {\n"
    "        return array_key_exists($this->key(), $this->array);\n"
    "    }\n"
    "\n"
    "    function rewind()\n"
    "    {\n"
    "        return reset($this->array);\n"
    "    }\n"
    "\n"
    "    function next()\n"
    "    {\n"
    "        return next($this->array);\n"
    "    }\n"
    "\n"
    "    function serialize()\n"
    "    {\n"
    "        return serialize($this->array);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return StringObject\n"
    "     */\n"
    "    function json()\n"
    "    {\n"
    "        return new StringObject(json_encode($this->array));\n"
    "    }\n"
    "\n"
    "    function indexOf($value)\n"
    "    {\n"
    "        return $this->search($value);\n"
    "    }\n"
    "\n"
    "    function lastIndexOf($value)\n"
    "    {\n"
    "        $find = false;\n"
    "        foreach ($this->array as $k => $v)\n"
    "        {\n"
    "            if ($value == $v)\n"
    "            {\n"
    "                $find = $k;\n"
    "            }\n"
    "        }\n"
    "\n"
    "        return $find;\n"
    "    }\n"
    "\n"
    "    function unserialize($str)\n"
    "    {\n"
    "        $this->array = unserialize($str);\n"
    "    }\n"
    "\n"
    "    function __get($key)\n"
    "    {\n"
    "        return $this->array[$key];\n"
    "    }\n"
    "\n"
    "    function __set($key, $value)\n"
    "    {\n"
    "        $this->array[$key] = $value;\n"
    "    }\n"
    "\n"
    "    function set($key, $value)\n"
    "    {\n"
    "        $this->array[$key] = $value;\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $key\n"
    "     * @return ArrayObject|StringObject\n"
    "     */\n"
    "    function get($key)\n"
    "    {\n"
    "        return self::detectType($this->array[$key]);\n"
    "    }\n"
    "\n"
    "    function delete($key)\n"
    "    {\n"
    "        if (isset($this->array[$key]))\n"
    "        {\n"
    "            return false;\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            unset($this->array[$key]);\n"
    "\n"
    "            return true;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    function clear()\n"
    "    {\n"
    "        $this->array = array();\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param mixed $k\n"
    "     * @return mixed|null\n"
    "     */\n"
    "    function offsetGet($k)\n"
    "    {\n"
    "        if (!array_key_exists($k, $this->array))\n"
    "        {\n"
    "            return null;\n"
    "        }\n"
    "        return $this->array[$k];\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param mixed $k\n"
    "     * @param mixed $v\n"
    "     */\n"
    "    function offsetSet($k, $v)\n"
    "    {\n"
    "        $this->array[$k] = $v;\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param mixed $k\n"
    "     */\n"
    "    function offsetUnset($k)\n"
    "    {\n"
    "        unset($this->array[$k]);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param mixed $k\n"
    "     * @return bool\n"
    "     */\n"
    "    function offsetExists($k)\n"
    "    {\n"
    "        return isset($this->array[$k]);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $val\n"
    "     * @return bool\n"
    "     */\n"
    "    function contains($val)\n"
    "    {\n"
    "        return in_array($val, $this->array);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $key\n"
    "     * @return bool\n"
    "     */\n"
    "    function exists($key)\n"
    "    {\n"
    "        return array_key_exists($key, $this->array);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $str\n"
    "     * @return StringObject\n"
    "     */\n"
    "    function join($str)\n"
    "    {\n"
    "        return new StringObject(implode($str, $this->array));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $offset\n"
    "     * @param $val\n"
    "     * @return bool|ArrayObject\n"
    "     */\n"
    "    function insert($offset, $val)\n"
    "    {\n"
    "        if ($offset > count($this->array))\n"
    "        {\n"
    "            return false;\n"
    "        }\n"
    "        return new ArrayObject(array_splice($this->array, $offset, 0, $val));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $find\n"
    "     * @param $strict\n"
    "     * @return mixed\n"
    "     */\n"
    "    function search($find, $strict = false)\n"
    "    {\n"
    "        return array_search($find, $this->array, $strict);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return int\n"
    "     */\n"
    "    function count()\n"
    "    {\n"
    "        return count($this->array);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return bool\n"
    "     */\n"
    "    function isEmpty()\n"
    "    {\n"
    "        return empty($this->array);\n"
    "    }\n"
    "\n"
    "\n"
    "    /**\n"
    "     * @return float|int\n"
    "     */\n"
    "    function sum()\n"
    "    {\n"
    "        return array_sum($this->array);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return float|int\n"
    "     */\n"
    "    function product()\n"
    "    {\n"
    "        return array_product($this->array);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $val\n"
    "     * @return int\n"
    "     */\n"
    "    function append($val)\n"
    "    {\n"
    "        return array_push($this->array, $val);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $val\n"
    "     * @return int\n"
    "     */\n"
    "    function prepend($val)\n"
    "    {\n"
    "        return array_unshift($this->array, $val);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return mixed\n"
    "     */\n"
    "    function pop()\n"
    "    {\n"
    "        return array_pop($this->array);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return mixed\n"
    "     */\n"
    "    function shift()\n"
    "    {\n"
    "        return array_shift($this->array);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $offset\n"
    "     * @param $length\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function slice($offset, $length = null)\n"
    "    {\n"
    "        return new ArrayObject(array_slice($this->array, $offset, $length));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return mixed\n"
    "     */\n"
    "    function randGet()\n"
    "    {\n"
    "        return self::detectType($this->array[array_rand($this->array, 1)]);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $value\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function remove($value)\n"
    "    {\n"
    "        $key = $this->search($value);\n"
    "        if ($key)\n"
    "        {\n"
    "            unset($this->array[$key]);\n"
    "        }\n"
    "\n"
    "        return $this;\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $fn callable\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function each(callable $fn)\n"
    "    {\n"
    "        if (array_walk($this->array, $fn) === false)\n"
    "        {\n"
    "            throw new \\RuntimeException(\"array_walk() failed.\");\n"
    "        }\n"
    "\n"
    "        return $this;\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $fn callable\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function map(callable $fn)\n"
    "    {\n"
    "        return new ArrayObject(array_map($fn, $this->array));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $fn callable\n"
    "     * @return mixed\n"
    "     */\n"
    "    function reduce(callable $fn)\n"
    "    {\n"
    "        return array_reduce($this->array, $fn);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     *  @return ArrayObject\n"
    "     */\n"
    "    function values()\n"
    "    {\n"
    "        return new ArrayObject(array_values($this->array));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $column_key\n"
    "     * @param null $index\n"
    "     * @return array|ArrayObject\n"
    "     */\n"
    "    function column($column_key, $index = null)\n"
    "    {\n"
    "        if ($index)\n"
    "        {\n"
    "            return array_column($this->array, $column_key, $index);\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            return new ArrayObject(array_column($this->array, $column_key));\n"
    "        }\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param null $search_value\n"
    "     * @param bool $strict\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function keys($search_value = null, $strict = false)\n"
    "    {\n"
    "        return new ArrayObject(array_keys($this->array, $search_value, $strict));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param int $sort_flags\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function unique($sort_flags = SORT_STRING)\n"
    "    {\n"
    "        return new ArrayObject(array_unique($this->array, $sort_flags));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param int $sort_flags\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function sort($sort_flags = SORT_REGULAR)\n"
    "    {\n"
    "        $newArray = $this->array;\n"
    "        sort($newArray, $sort_flags);\n"
    "\n"
    "        return new ArrayObject($newArray);\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param bool $preserve_keys\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function reverse($preserve_keys = false)\n"
    "    {\n"
    "        return new ArrayObject(array_reverse($this->array, $preserve_keys));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function shuffle()\n"
    "    {\n"
    "        if (shuffle($this->array) === false)\n"
    "        {\n"
    "            throw new \\RuntimeException(\"shuffle() failed.\");\n"
    "        }\n"
    "\n"
    "        return $this;\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $size\n"
    "     * @param bool $preserve_keys\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function chunk($size, $preserve_keys = false)\n"
    "    {\n"
    "        return new ArrayObject(array_chunk($this->array, $size, $preserve_keys));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * 交换数组中的键和值\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function flip()\n"
    "    {\n"
    "        return new ArrayObject(array_flip($this->array));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $fn callable\n"
    "     * @param int $flag\n"
    "     * @return ArrayObject\n"
    "     */\n"
    "    function filter(callable $fn, $flag = 0)\n"
    "    {\n"
    "        return new ArrayObject(array_filter($this->array, $fn, $flag));\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @param $value\n"
    "     * @return ArrayObject|StringObject\n"
    "     */\n"
    "    static function detectType($value)\n"
    "    {\n"
    "        if (is_array($value))\n"
    "        {\n"
    "            return new ArrayObject($value);\n"
    "        }\n"
    "        elseif (is_string($value))\n"
    "        {\n"
    "            return new StringObject($value);\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            return $value;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    /**\n"
    "     * @return array\n"
    "     */\n"
    "    function toArray()\n"
    "    {\n"
    "        return $this->array;\n"
    "    }\n"
    "}\n";

static const char* swoole_library_source_alias =
    "\n"
    "if (ini_get('swoole.use_shortname') === 'On') {\n"
    "    class_alias(Swoole\\Coroutine\\WaitGroup::class, Co\\WaitGroup::class, false);\n"
    "}\n";

static const char* swoole_library_source_function =
    "\n"
    "if (!function_exists('_string')) {\n"
    "    /**\n"
    "     * @param  string $str\n"
    "     * @return Swoole\\StringObject\n"
    "     */\n"
    "    function _string($str)\n"
    "    {\n"
    "        return new Swoole\\StringObject($str);\n"
    "    }\n"
    "}\n"
    "\n"
    "if (!function_exists('_array')) {\n"
    "    /**\n"
    "     * @param  array $array\n"
    "     * @return Swoole\\ArrayObject\n"
    "     */\n"
    "    function _array($array)\n"
    "    {\n"
    "        return new Swoole\\ArrayObject($array);\n"
    "    }\n"
    "}\n";

static void php_swoole_load_library()
{
    zend::eval(swoole_library_source_constant, "@swoole-src/library/constant.php");
    zend::eval(swoole_library_source_std_array, "@swoole-src/library/std/array.php");
    zend::eval(swoole_library_source_ext_curl, "@swoole-src/library/ext/curl.php");
    zend::eval(swoole_library_source_core_coroutine_wait_group, "@swoole-src/library/core/Coroutine/WaitGroup.php");
    zend::eval(swoole_library_source_core_string_object, "@swoole-src/library/core/StringObject.php");
    zend::eval(swoole_library_source_core_array_object, "@swoole-src/library/core/ArrayObject.php");
    zend::eval(swoole_library_source_alias, "@swoole-src/library/alias.php");
    zend::eval(swoole_library_source_function, "@swoole-src/library/function.php");
}
