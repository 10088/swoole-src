/**
 * Generated by build-library.php, Please DO NOT modify!
 */

zend::eval("\nfunction swoole_array_walk(&$array, callable $callback, $userdata = null)\n{\n    foreach ($array as $key => &$item) {\n        $callback($item, $key, $userdata);\n    }\n}\n\nfunction swoole_array_walk_recursive(&$array, callable $callback, $userdata = null)\n{\n    foreach ($array as $key => &$item) {\n        if (is_array($item)) {\n            swoole_array_walk_recursive($item, $callback, $userdata);\n        } else {\n            $callback($item, $key, $userdata);\n        }\n    }\n}\n", "/path/to/swoole-src/library/array.php");
zend::eval("\ndefine('SWOOLE_LIBRARY', true);\n", "/path/to/swoole-src/library/constant.php");
zend::eval("\n\nclass swoole_curl_handler\n{\n    /**\n     * @var Swoole\\Coroutine\\Http\\Client\n     */\n    private $client;\n    private $info;\n    private $outputStream;\n\n    /**\n     * @var callable\n     */\n    private $headerFunction ;\n\n    /**\n     * @var callable\n     */\n    private $readFunction;\n\n    private $writeFunction;\n\n    private $progressFunction;\n\n    public $return_transfer = true;\n    public $method;\n    public $headers = [];\n\n    function create($url)\n    {\n        $info = parse_url($url);\n        if ($info['scheme'] == 'https') {\n            $ssl = true;\n        } else {\n            $ssl = false;\n        }\n        if (empty($info['port'])) {\n            $port = $ssl ? 443 : 80;\n        } else {\n            $port = intval($info['port']);\n        }\n        $this->info = $info;\n        $this->client = new Swoole\\Coroutine\\Http\\Client($info['host'], $port, $ssl);\n    }\n\n    function execute()\n    {\n        $client = $this->client;\n        $client->setMethod($this->method);\n        if ($this->headers) {\n            $client->setHeaders($this->headers);\n        }\n        if (!$client->execute($this->getUrl())) {\n            return false;\n        }\n\n        if ($client->headers and $this->headerFunction) {\n            $cb = $this->headerFunction;\n            if ($client->statusCode == 200) {\n                $cb($this, \"HTTP/1.1 200 OK\\r\\n\");\n            }\n            foreach ($client->headers as $k => $v) {\n                $cb($this, \"$k: $v\\r\\n\");\n            }\n            $cb($this, '');\n        }\n\n        if ($client->body and $this->readFunction) {\n            $cb = $this->readFunction;\n            $cb($this, $this->outputStream, strlen($client->body));\n        }\n\n        if ($this->return_transfer) {\n            return $client->body;\n        } else {\n            if ($this->outputStream) {\n                fwrite($this->outputStream, $client->body);\n            } else {\n                echo $this->outputStream;\n            }\n            return true;\n        }\n    }\n\n    function close()\n    {\n        $this->client = null;\n        return true;\n    }\n\n    function getErrorCode()\n    {\n        return $this->client->errCode;\n    }\n\n    function getErrorMsg()\n    {\n        return $this->client->errMsg;\n    }\n\n    private function getUrl()\n    {\n        if (empty($this->info['path'])) {\n            $url = '/';\n        } else {\n            $url = $this->info['path'];\n        }\n        if (!empty($this->info['query'])) {\n            $url .= '?' . $this->info['query'];\n        }\n        if (!empty($this->info['query'])) {\n            $url .= '#' . $this->info['fragment'];\n        }\n        return $url;\n    }\n\n    function setOption($opt, $value)\n    {\n        switch ($opt) {\n            case CURLOPT_URL:\n                $this->create($value);\n                break;\n            case CURLOPT_RETURNTRANSFER:\n                $this->return_transfer = $value;\n                break;\n            case CURLOPT_ENCODING:\n                if (empty($value)) {\n                    $value = 'gzip';\n                }\n                $this->headers['Accept-Encoding'] = $value;\n                break;\n            case CURLOPT_POST:\n                $this->method = 'post';\n                break;\n            case CURLOPT_HTTPHEADER:\n                foreach ($value as $header) {\n                    list($k, $v) = explode(':', $header);\n                    $v = trim($v);\n                    if ($v) {\n                        $this->headers[$k] = $v;\n                    }\n                }\n                break;\n            case CURLOPT_CUSTOMREQUEST:\n                break;\n            case CURLOPT_PROTOCOLS:\n                if ($value > 3) {\n                    throw new swoole_curl_exception(\"option[$opt=$value]  is not supports.\");\n                }\n                break;\n            case CURLOPT_HTTP_VERSION:\n                break;\n            case CURLOPT_SSL_VERIFYHOST:\n                break;\n            case CURLOPT_SSL_VERIFYPEER:\n                $this->client->set(['ssl_verify_peer' => $value]);\n                break;\n            case CURLOPT_CONNECTTIMEOUT:\n                $this->client->set(['connect_timeout' => $value]);\n                break;\n            case CURLOPT_FILE:\n                $this->outputStream = $value;\n                break;\n            case CURLOPT_HEADER:\n                break;\n            case CURLOPT_HEADERFUNCTION:\n                $this->headerFunction = $value;\n                break;\n            case CURLOPT_READFUNCTION:\n                $this->readFunction = $value;\n                break;\n            case CURLOPT_WRITEFUNCTION:\n                $this->writeFunction = $value;\n                break;\n            case CURLOPT_PROGRESSFUNCTION:\n                $this->progressFunction = $value;\n                break;\n            default:\n                var_dump($opt, $value);\n                throw new swoole_curl_exception(\"option[$opt] is not supports.\");\n        }\n        return true;\n    }\n\n    function reset()\n    {\n        $this->client->body = '';\n    }\n}\n\nclass swoole_curl_exception extends RuntimeException\n{\n\n}\n\nfunction swoole_curl_init()\n{\n    return new swoole_curl_handler();\n}\n\nfunction swoole_curl_setopt(swoole_curl_handler $obj, $opt, $value)\n{\n    return $obj->setOption($opt, $value);\n}\n\nfunction swoole_curl_setopt_array(swoole_curl_handler $obj, $array)\n{\n    foreach ($array as $k => $v) {\n        if ($obj->setOption($k, $v) === false) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nfunction swoole_curl_exec(swoole_curl_handler $obj)\n{\n    return $obj->execute();\n}\n\n\nfunction swoole_curl_close(swoole_curl_handler $obj)\n{\n    return $obj->close();\n}\n\nfunction swoole_curl_error(swoole_curl_handler $obj)\n{\n    return $obj->getErrorMsg();\n}\n\nfunction swoole_curl_errno(swoole_curl_handler $obj)\n{\n    return $obj->getErrorCode();\n}\n\nfunction swoole_curl_reset(swoole_curl_handler $obj)\n{\n    return $obj->reset();\n}\n", "/path/to/swoole-src/library/curl.php");
